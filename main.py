import re
import yaml
from pathlib import Path
from datetime import datetime, time, timedelta 
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.client.default import DefaultBotProperties
import asyncio
import logging



logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

CONFIG_FILE = 'config.yaml'

def load_config():
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        
        required_keys = ['bot_token', 'directory', 'files', 'default_time', 'user_chat_id', 'check_interval']
        if not config or not all(key in config for key in required_keys):
            missing = [k for k in required_keys if k not in config]
            logger.error(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∫–ª—é—á–∏ –≤ –∫–æ–Ω—Ñ–∏–≥–µ: {missing}")
            return None
            
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞
        if not isinstance(config['check_interval'], int) or config['check_interval'] < 1:
            logger.error("check_interval –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ü–µ–ª—ã–º —á–∏—Å–ª–æ–º (—Å–µ–∫—É–Ω–¥—ã) –∏ –Ω–µ –º–µ–Ω—å—à–µ 1")
            return None
            
        return config
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥–∞: {str(e)}")
        return None

config = load_config()
if not config:
    exit(1)

bot = Bot(token=config['bot_token'], default=DefaultBotProperties(parse_mode='HTML'))
dp = Dispatcher()

def parse_task_line(line, default_time):
    line = line.strip().split('#')[0].strip()
    
    if not re.match(r'^- \[ \]', line):
        return None
    
    content = re.sub(r'^- \[ \]\s*', '', line)
    
    time_start = None
    elements = {}
    task_text = []

    parts = re.split(r'(\s*[‚è∞‚è≥üìÖ]\s*)', content)
    for i, part in enumerate(parts):
        if re.match(r'^\s*[‚è∞‚è≥üìÖ]\s*$', part):
            emoji = part.strip()
            if i+1 < len(parts):
                value = parts[i+1].split()[0] if parts[i+1] else None
                if value and re.match(r'^[\d:-]+$', value):
                    elements[emoji] = value
                    parts[i+1] = parts[i+1].replace(value, '', 1).strip()
        else:
            task_text.append(part.strip())

    if task_text:
        first_part = task_text[0]
        time_match = re.match(r'^(\d{1,2}:\d{2})(\s+|$)', first_part)
        if time_match:
            time_start = time_match.group(1)
            task_text[0] = first_part.replace(time_match.group(0), '', 1).strip()

    task_clean = ' '.join(filter(None, task_text))
    time_clock = elements.get('‚è∞')
    
    def is_valid_time(t):
        return re.fullmatch(r'\d{1,2}:\d{2}', t) is not None
    
    def is_valid_date(d):
        try:
            datetime.strptime(d, '%Y-%m-%d')
            return True
        except:
            return False
    
    final_time = next(
        (t for t in [time_clock, time_start, default_time] 
        if t and is_valid_time(t)),
        default_time
    )
    
    valid_dates = {}
    for emoji in ['‚è≥', 'üìÖ']:
        value = elements.get(emoji)
        if value and is_valid_date(value):
            valid_dates[emoji] = value

    return {
        'task': task_clean,
        'time': final_time,
        'dates': valid_dates
    } if task_clean else None

async def check_files(config):
    results = []
    directory = Path(config['directory'])
    
    for filename in config['files']:
        filepath = directory / filename
        if not filepath.exists():
            logger.warning(f"–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {filepath}")
            continue
            
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    task_data = parse_task_line(line, config['default_time'])
                    if task_data:
                        results.append({
                            'file': filename,
                            'line': line_num,
                            'data': task_data
                        })
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {str(e)}")
    
    return results


async def process_tasks_for_time(check_time: datetime):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏"""
    tasks = await check_files(config)
    current_date = check_time.date()
    current_time = check_time.time().replace(second=0, microsecond=0)
    
    for task in tasks:
        data = task['data']
        task_text = data["task"]
        time_str = data["time"]
        predate = data["dates"].get("‚è≥")
        postdate = data["dates"].get("üìÖ")

        try:
            task_time = datetime.strptime(time_str, '%H:%M').time()
            task_time = task_time.replace(second=0, microsecond=0)
        except ValueError:
            continue

        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–∞—Ç
        predate_obj = datetime.strptime(predate, '%Y-%m-%d').date() if predate else None
        postdate_obj = datetime.strptime(postdate, '%Y-%m-%d').date() if postdate else None

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏
        if task_time == current_time:
            if predate_obj == current_date:
                message = f"‚è≥ [–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ] –ù–∞–ø–æ–º–∏–Ω–∞—é {postdate} —É –í–∞—Å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ: \n\n {task_text}"
                await bot.send_message(config['user_chat_id'], message)
            
            if postdate_obj == current_date:
                message = f"üìÖ [–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ] –ù–∞–ø–æ–º–∏–Ω–∞—é: \n\n {task_text}"
                await bot.send_message(config['user_chat_id'], message)
            
            if not predate and not postdate:
                message = f"‚è∞ [–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ] –ù–∞–ø–æ–º–∏–Ω–∞—é: \n\n {task_text}"
                await bot.send_message(config['user_chat_id'], message)

async def check_and_notify():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤"""
    now = datetime.now()
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
    if not hasattr(check_and_notify, 'last_check_time'):
        check_and_notify.last_check_time = now - timedelta(seconds=config['check_interval'])
        logger.info(f"–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è last_check_time: {check_and_notify.last_check_time}")
    
    # –†–∞—Å—á–µ—Ç –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
    time_diff = (now - check_and_notify.last_check_time).total_seconds()
    
    if time_diff > config['check_interval'] * 1.5:
        missed_checks = int(time_diff // config['check_interval'])
        logger.warning(f"–ü—Ä–æ–ø—É—â–µ–Ω–æ –ø—Ä–æ–≤–µ—Ä–æ–∫: {missed_checks}, –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ...")
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –ø–µ—Ä–∏–æ–¥–æ–≤
        for i in range(1, missed_checks + 1):
            check_time = check_and_notify.last_check_time + timedelta(
                seconds=config['check_interval'] * i
            )
            logger.debug(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ {check_time}")
            await process_tasks_for_time(check_time)
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á
    logger.info(f"–û–±—ã—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤ {now}")
    await process_tasks_for_time(now)
    
    # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
    check_and_notify.last_check_time = now

async def scheduler():
    """–ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
    while True:
        try:
            await check_and_notify()
            await asyncio.sleep(config['check_interval'])
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–µ: {str(e)}")
            await asyncio.sleep(10)  # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π



@dp.message(Command("start"))
async def send_welcome(message: types.Message):
    await message.reply(
        "üîî –ë–æ—Ç –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –∑–∞–ø—É—â–µ–Ω!\n"
        "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≤ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π —á–∞—Ç.\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /check –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∑–∞–¥–∞—á"
    )

@dp.message(Command("check"))
async def check_tasks(message: types.Message):
    tasks = await check_files(config)
    
    if not tasks:
        await message.reply("‚ùå –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return
    
    response = ["üìã –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á:\n"]
    for task in tasks:
        task_info = task['data']
        dates = '\n'.join([f"{emoji} {date}" for emoji, date in task_info['dates'].items()]) or ""
        
        response.append(
            f" {task_info['task']} –≤ {task_info['time']} {dates}\n"
            f"-------"
        )
    
    await message.reply('\n'.join(response))

async def main():
    asyncio.create_task(scheduler())
    await dp.start_polling(bot)

if __name__ == '__main__':
    asyncio.run(main())
